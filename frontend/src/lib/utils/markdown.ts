import { marked, type Token } from 'marked';
import DOMPurify from 'dompurify';
import Spoiler from '$lib/components/comments/Spoiler.svelte';
import { mount } from 'svelte';

type SpoilerToken = Token & {
	type: 'spoiler';
	raw: string;
	text: string;
	tokens: Token[];
};

const spoilerExtension = {
	name: 'spoiler',
	level: 'inline' as const,
	start(src: string) {
		return src.match(/\|\|/)?.index;
	},
	tokenizer(src: string) {
		const rule = /^\|\|([^|]*(?:\|(?!\|)[^|]*)*)\|\|/s;

		const match = rule.exec(src);
		if (match) {
			// Tokenize the content inside the spoiler
			const text = match[1] || '';
			const token: SpoilerToken = {
				type: 'spoiler',
				raw: match[0],
				text,
				tokens: []
			};
			return token;
		}
		return undefined;
	},
	renderer(token: Token): string | false {
		if (token.type === 'spoiler') {
			const spoilerToken = token as SpoilerToken;

			return `<div class="spoiler-wrapper">${spoilerToken.text}</div>`;
		}
		return false;
	}
};

marked.use({ extensions: [spoilerExtension] });

export function parseAndSanitize(content: string): string {
	const rawHtml = marked.parse(content, { breaks: true, gfm: true }) as string;
	return DOMPurify.sanitize(rawHtml);
}

export function mountSpoilers(container: HTMLElement | null | undefined) {
	if (!container) return;

	// Find placeholder div generated by markdown renderer
	const spoilerNodes = container.querySelectorAll<HTMLElement>('.spoiler-wrapper');

	spoilerNodes.forEach((node) => {
		// Prevent mounting the component multiple times on the same element
		if (node.dataset.hydrated === 'true') {
			return;
		}

		const content = node.textContent || '';
		node.innerHTML = '';

		// Mount the interactive component
		mount(Spoiler, {
			target: node,
			props: { content }
		});

		// Mark this node as "hydrated" to avoid re-mounting
		node.dataset.hydrated = 'true';
	});
}
